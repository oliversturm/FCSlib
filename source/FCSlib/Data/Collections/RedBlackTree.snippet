    private static RedBlackTree<T> Balance(Color nodeColor,
       RedBlackTree<T> left, T? value, RedBlackTree<T> right) {
      const Color R = Color.Red;
      const Color B = Color.Black;
      RedBlackTree<T> TT(Color c, RedBlackTree<T> l, T? v, RedBlackTree<T> r) => new(c, l, v, r);

      // Note that in contrast to Haskell, these patterns do not explicitly
      // match T as opposed to E. If we wanted to determine explicitly
      // that the tree is not empty, we'd need a more complex property
      // based pattern. To avoid this, the tree initializes with a 
      // None color, so that the B and R matches only catch trees that 
      // are not empty.
      return (nodeColor, left, value, right) switch
      {
        (B, (R, (R, var a, var x, var b), var y, var c), var z, var d) =>
          TT(R, TT(B, a, x, b), y, TT(B, c, z, d)),
        (B, (R, var a, var x, (R, var b, var y, var c)), var z, var d) =>
          TT(R, TT(B, a, x, b), y, TT(B, c, z, d)),
        (B, var a, var x, (R, (R, var b, var y, var c), var z, var d)) =>
          TT(R, TT(B, a, x, b), y, TT(B, c, z, d)),
        (B, var a, var x, (R, var b, var y, (R, var c, var z, var d))) =>
          TT(R, TT(B, a, x, b), y, TT(B, c, z, d)),
        (var color, var a, var x, var b) => TT(color, a, x, b)
      };
    }
